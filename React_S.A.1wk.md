### **1. 자바스크립트(Javascript)의 자료형과 자바스크립트만의 특성**
##### 1) 명시적 타입이 없다. 자바, C 언어와는 달리, 변수를 미리 규정하는 '정적 타입'이 없고 '**동적 타입**'이기때문에 실행 도중(값을 할당할 때) 정해진다. 기본적으로 자동 형변환되며, 엄격한 타입 구분이 없는 **느슨한** 타입이다.
##### 즉, 자바스크립트 변수는 특정 시간에 특정 값을 가리키는 이름 자체일 뿐, 변수의 값과 타입은 실행 중에 얼마든지 바뀔 수 있다.
##### 변수에 타입을 규정하는 특별한 구문이 없다. var, let 이라는 변수 선언 예약어 만으로도 가능하기에, 변수 타입(Data Type) 검사 등이 엄격하지 않다.
######  - 자바스크립트 변수 타입의 느슨한 구분은, 다음과 같은 타입들을 변수에 대입이 가능하다.
          - 종류 : 문자열형,숫자형,논리값형,null,undefined,symbol (6개)
            . string 타입 : 대부분의 타 프로그래밍 언어와 같음
            . number 타입 : 타 프로그래밍 언어와 달리, 내부적으로 64 비트 부동소수점 만 지원
            . boolean 타입 : true,false 2개 값 만 가능
            . undefined 타입 : 변수가 선언 만 되고 값이 주어지지 않은 경우
            . null 타입 : 선언된 변수가 null 값(값을 정할 수 없음, 0/0 등)으로 된 것
            . symbol 타입 : (ECMAScript 6에 신규로 추가)

##### 2) JavaScript 형변환은 두가지다. 자바스크립트 엔진이 필요에 따라 '암시적변환'을, 혹은 개발자의 의도에 따라 ‘명시적변환’ 을 실행한다. 
##### *암시적변환* 이란 자바스크립트 엔진이 필요에 따라 자동으로 데이터타입을 변환시키는 것이다.
#####  - 산술 연산자 (+), 다른 연산자(-,곱하기,/,%), 동치 비교( == )
##### *명시적변환*이란 개발자가 의도를 가지고 데이터타입을 변환시키는 것이다.
##### 타입을 변경하는 기본적인 방법은 `Object(), Number(), parseInt(), parseFloat(), String(), Boolean()` 와 같은 함수를 
##### 이용하는데 new 연산자가 없다면 사용한 함수는 타입을 변환하는 함수로써 사용된다.

##### 3) 동치비교
##### *동등 연산자(==)* : 두 값이 같은지 비교하는데 값을 공통 형태로 변환한 후에 비교한다. 변수 선언시 Type을 따로 지정하지 않는 Javacript의 경우
##### 하나 또는 양쪽이 형 변환을 거치고 두 값을 비교한다.
##### 예를들어, 문자 '1'과 숫자 1은 엄연히 다르지만, A == B의 경우 ToNumber(A) === B로 변환되어 비교되며, 결과는 True로 나타난다.
##### *일치 연산자(===)* : data type이 고려된 정확한 비교이다. 따라서 정확한 비교를 하고자 할 때에는 == 를 사용하는 것보다 안전하다.

##### 4) 느슨한 타입(loosely typed)의 동적(dynamic) 언어의 문제점은 무엇이고 보완할 수 있는 방법
##### - 동적타입 언어는 런타임 시 확인할 수 밖에 없기 때문에, 코드가 길고 복잡해질 경우 타입 에러를 찾기가 어려워진다. 
##### 실행 도중에 변수에 예상치 못한 타입이 들어와 Type Error가 발생하는 경우가 생길 수 있다. 정적 언어와 달리 실행되는 시점에서 오류를 출력한다. 
##### 특히 프로젝트의 크기가 크거나 협업을 하는 과정에서 변수의 타입이 일치하지 않는 경우가 생길 수 있으므로 주의를 기울여야 한다.
##### 자바스크립트가 가진 동적 언어의 단점을 보완하는 방법으로는 TypeScript를 사용하는 방법이 있다. 타입스크립트란 자바스크립트에서 코드를 입력할 때 타입을 미리 부여하는 기능을 추가한 정적 타입 언어이다.

##### 5) undefined와 null의 차이점
##### - undefined은 변수를 선언하고 값을 할당하지 않은 상태, null은 변수를 선언하고 빈 값을 할당한 상태(빈 객체)이다. 
##### 즉, undefined는 자료형이 없는 상태이다. 따라서 typeof를 통해 자료형을 확인해보면 null은 object로, undefined는 undefined가 출력되는 것을 확인할 수 있다.
###### 아래의 경우에 변수가 undefined를 반환한다.
            . 값을 할당하지 않은 변수
            . 메서드와 선언에서 변수가 할당받지 않은 경우
            . 함수가 값을 return 하지 않았을 때
##### null은 원시값(Primitive Type) 중 하나로, 어떤 값이 의도적으로 비어있음을 표현한다. 
##### undefined는 값이 지정되지 않은 경우를 의미하지만, null의 경우에는 해당 변수가 어떤 객체도 가리키고 있지 않다는 것을 의미한다. 

### **2. JavaScript 객체와 불변성**
##### 1) 자바스크립트 데이터의 두가지 타입으로 원시 자료형(primitive type)과 참조 자료형(reference type)이 있다.
##### - 원시 자료형이 할당될 때에는 변수에 값(value) 자체가 담기고, 참조 자료형이 할당될 때는 보관함의 주소(reference)가 담긴다.
###### 원시 자료형은 모두 “하나”의 정보, 즉, 데이터를 담고 있다. 자바스크립트에선 원시 자료형이 아닌 모든 것은 참조 자료형이다.
###### 참조 자료형으로는 배열([])과 객체({}), 함수(function(){})가 대표적이다.

##### 2) 불변객체란 '변하지 않는 객체' 즉 이미 할당된 객체가 변하지 않는다는 뜻을 가지고 있다.
##### 마찬가지로 참조형 데이터도 데이터 자체를 변경하고자 하면 즉, 새로운 데이터를 할당한다면 기본형 데이터와 같이 기존 데이터는 변경되지 않는다.
###### 특정 객체를 불변 객체로 만들려면 'Object.freeze'라는 함수를 사용하면 된다. const는 선언된 변수명이 다른 값을 가리키지 못하도록 막는 역할을 한다고 할 수 있고, freeze는 객체내 속성 값을 바꾸지 못하게 하는 역할을 한다고 보면 된다.

##### 3) 얕은 복사란 바로 아래 단계의 값들만 복사하는 방법이고, 깊은 복사란 내부의 모든 값들을 하나하나 찾아서 전부 복사하는 방법이다. 

### **3. 호이스팅과 TDZ**
##### 1) 호이스팅은 함수 안에 있는 선언들을 모두 끌어 올려서 해당 함수 유효 스코프의 최상단에 선언 하는 것을 말한다.
##### TDZ란 선언 전에 변수를 사용하는 것을 비 허용하는 개념상의 공간이다.
##### 스코프(scope)는 식별자(ex. 변수명, 함수명, 클래스명 등)의 유효범위를 뜻하며, 선언된 위치에 따라 유효 범위가 달라진다. 전역에 선언된 변수는 전역 스코프를, 지역에 선언된 변수는 지역 스코프를 갖는다. 전역 변수는 어디에서든지 참조가 가능한 값이다. 반면, 지역 변수는 함수 몸체 내부를 말한다. 따라서 지역 변수는 자신의 지역 스코프와 그 하위 지역 스코프에서 유효하다.
##### 한 가지 주의해야 할 점은, 자바스크립트에서 모든 코드 블록(if, for, while, try/catch 등)이 지역 스코프를 만들며, 이러한 특성을 블록 레벨 스코프라 한다. 하지만 var 키워드로 선언된 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정한다. 이를 함수 레벨 스코프라 한다.

##### 2) 함수 선언식과 함수 표현식의 주요 차이점은 호이스팅에서 차이가 발생한다.
##### 함수 선언식은 함수 전체를 호이스팅 한다. 정의된 범위의 맨 위로 호이스팅되서 함수 선언 전에 함수를 사용할 수 있다는 것이고, 
##### 함수 표현식은 별도의 변수에 할당하게 되는데, 변수는 선언부와 할당부를 나누어 호이스팅 하게 된다. 선언부만 호이스팅하게 된다.

##### 3) 자바스크립트 변수(var, let, const)
###### *var*은 변수 중복 선언 가능하여, 예기치 못한 값을 반환할 수 있다. 함수 레벨 스코프로 인해 함수 외부에서 선언한 변수는 모두 전역 변수로 된다.
###### *let*은  변수 중복 선언이 불가하지만, 재할당은 가능하다.
###### *const*가 let과 다른 점이 있다면, 반드시 선언과 초기화를 동시에 진행되어야 한다는 점이다. const도 let과 마찬가지로 재선언이 불가하며, 더 나아가 재할당도 불가하다. 재할당의 경우, 원시 값은 불가능하지만, 객체는 가능하다.
##### 4) 실행 컨텍스트와 콜 스택
##### **실행 컨텍스트**는 자바스크립트 코드가 실행되는 환경을 의미한다. 자바스크립트에서 대표적으로 두 가지 타입의 Execution context가 있다.
##### 실행할 코드에 제공할 환경 정보들을 모아놓은 객체들로 자바스크립트의 동적 언어로서의 성격을 가장 잘 파악할 수 있는 개념이다.
##### - Global Execution context
###### 자바스크립트 엔진이 처음 코드를 실행할 때 Global Execution Context가 생성된다. 생성 과정에서 전역 객체인 Window Object (Node는 Global) 를 생성하고 this가 Window 객체를 가리키도록 한다.
##### - Function Execution context
###### 자바스크립트 엔진은 함수가 호출 될 때마다 호출 된 함수를 위한 Execution Context를 생성한다. 모든 함수는 호출되는 시점에 자신만의 Execution Context를 가진다.

##### 자바스크립트는 실행 컨텍스트가 활성화되는 시점에 다음과 같은 현상이 발생한다.
            . 호이스팅이 발생한다(선언된 변수를 위로 끌어올린다)
            . 외부 환경 정보를 구성한다
            . this 값을 설정한다.
            
##### 콜스택(call stack)이란 코드가 실행되면서 생성되는 Execution Context를 저장하는 자료구조로 프로그램이 함수 호출을 추적할 때 사용한다. 
##### 엔진이 처음 script를 실행할 때, Global Execution Context를 생성하고 이를 Call Stack에 push한다.
##### 그 후 엔진이 함수를 호출할 때 마다 함수를 위한 Execution Context를 생성하고 이를 Call Stack에 push 한다.
##### 자바스크립트 엔진은 Call Stack의 Top에 위치한 함수를 실행하며 함수가 종료되면 stack에서 제거(pop)하고 제어를 다음 Top에 위치한 함수로 이동한다.

##### 5) 스코프 체인, 변수 은닉화
##### 스코프 체인이란 일종의 '객체의 리스트'로서, 전역 객체와 중첩된 함수의 스코프의 레퍼런스를 차례로 저장하고, 의미 그대로 각각의 스코프가 어떻게 연결(chain)되고 있는지 보여주는 것을 말한다. 어떤 경계 A의 외부에서 선언한 변수는 A의 외부뿐 아니라 A의 내부에서도 접근이 가능하지만, A의 내부에서 선언한 변수는 오직 A의 내부에서만 접근할 수 있다. 이러한 식별자의 유효범의를 안에서부터 바깥으로 차례로 검색해나가는 것을 스코프 체인이라고 부른다.

##### 변수 은닉화란 외부 객체로부터 '속성 값(데이터, 멤버 변수값)'을 감추는 특성으로, 직접적으로 변경되면 안 되는 변수에 대한 접근을 막는 것을 은닉화라고 한다.

### **4. 실습과제**
          // 실습과제
          let b = 1;

          function hi () {

          const a = 1;

          let b = 100;

          b++;

          console.log(a,b);

          }

          console.log(a); // a가 지역(local)스코프로 선언되어 바깥의 범위에서는 undefined.

          console.log(b); //1로 찍힐 것이다. 1번째 라인에서 b가 정의되어 있다.

          hi(); // console.log(a,b); 이 출력됨. 1, 101

          console.log(b); // 첫 줄 let b = 1; 이 출력됨. 1

          // 수정
          let b = 1;
          const a = 1;	// a가 전역(global)스코프로 선언되어 바깥의 범위에서도 1 출력.
          function hi () {

              let b = 100;
              b++;
              console.log(a,b);
          }

          console.log(a);
          console.log(b); 
          hi();
          console.log(b);
