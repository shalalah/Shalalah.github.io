## API
#### API는 프로그램과 프로그램을 연결시켜주는 매개체
**API(Application Programming Interface;애플리케이션 프로그래밍 인터페이스)
"애플리케이션(스마트폰, 카카오톡 서버 등 서로 다른 프로그램)이 인터페이싱하는(요청과 응답을 주고받는) 체계"**

API를 쉽게 이야기하면 규칙들의 집합이다.
대신할 프로그램의 기능들을 미리 정리해서 규칙을 잘 세워둔다면, 
클라이언트는 접근할 프로그램을 모르더라도 API를 이용해 손쉽게 통신을 할 수 있게 된다.
그렇게 되면 클라이언트 프로그램은 접근해야 하는 프로그램에 접근하지 않고 편하게 API를 통해 정보를 요청할 수 있도록 된다.
이때 API 서버는 규격화 되어 있는 서버라고 생각하면 된다.

##### **REST(Representational State Transfer) API는 
웹상에서 사용되는 여러 리소스를 HTTP URI로 표현하고, 해당 리소스에 대한 행위를 HTTP Method로 정의하는 방식이다 **

"리소스(HTTP URI로 정의됨)를 어떻게 하겠다(HTTP Method + Payload)를 구조적으로 깔끔하게 표현하는 방법"

###### <REST 구성요소>
*1. 자원 : URI* 모든 자원에 고유한 ID가 존재한다, 이 자원은 Server에 존재한다. 	
자원을 구별하는 ID는 '/groups/:group_id' 와 같은 HTTP URI다.
Client는 URI를 이용해서 자원을 지정하고 해당 자원의 상태(정보)에 대한 조작을 Server에 요청한다

*2. 행위 : HTTP Method*  HTTP 프로토콜의 Method를 사용한다
HTTP 프로토콜은 GET, POST, PUT, DELETE 와 같은 메서드를 제공한다
	- GET : GET를 통해 해당 리소스를 조회합니다. 리소스를 조회하고 해당 도큐먼트에 대한 자세한 정보를 가져온다.
	- POST : POST를 통해 해당 URI를 요청하면 리소스를 생성한다.
	- PUT : PUT를 통해 해당 리소스를 수정한다.
	- DELETE : DELETE를 통해 리소스를 삭제한다.
	
*3. 표현 :* Client가 자원의 상태(정보)에 대한 조작을 요청하면 Server는 이에 적절한 응답(Representation)을 보낸다.
REST에서 하나의 자원은 JSON, XML, TEXT, RSS 등 여러 형태의 Representation으로 나타내어 질 수 있다.
JSON(자바스킙트 객체 표기법) 혹은 XML를 통해 데이터를 주고 받는 것이 일반적이다.

## JWT (Json Web Token)란 Json 포맷을 이용하여 사용자에 대한 속성을 저장하는 Claim 기반의 Web Token이다.
JWT는 토큰 자체를 정보로 사용하는 Self-Contained 방식으로 정보를 안전하게 전달한다. 
주로 회원 인증이나 정보 전달에 사용되는 JWT는 아래의 로직을 따라서 처리된다.

애플리케이션이 실행될 때, JWT를 static 변수와 로컬 스토리지에 저장하게 된다. 
static 변수에 저장되는 이유는 HTTP 통신을 할 때마다 JWT를 HTTP 헤더에 담아서 보내야 하는데, 
이를 로컬 스토리지에서 계속 불러오면 오버헤드가 발생하기 때문이다. 
클라이언트에서 JWT를 포함해 요청을 보내면 서버는 허가된 JWT인지를 검사한다. 
또한 로그아웃을 할 경우 로컬 스토리지에 저장된 JWT 데이터를 제거한다. 
(실제 서비스의 경우에는 로그아웃 시, 사용했던 토큰을 blacklist라는 DB 테이블에 넣어 해당 토큰의 접근을 막는 작업을 해주어야 한다.)

###### JWT는 Header, Payload, Signature 로 3부분으로 이루어진다.
	- Header : Signature를 해싱하기 위한 알고리즘 정보들이 담김
  - Payload : 서버와 클라이언트가 주고받는, 시스템에서 실제로 사용될 정보에 대한 내용들을 담고 있음
	- Signature : 토큰의 유효성 검증을 위한 문자열

*1. header(헤더)* : 헤더는 해당 토큰이 해싱된 알고리즘 방식을 알려준다. JWT를 어떻게 검증할 수 있을지에 대한 정보이다. 
alg는 해싱에 사용된 알고리즘(RSA, SHA256 등), typ은 토큰의 타입(주로 JWT)으로 두가지 정보를 지닌다.
	- 토큰 타입 지정 ex.) "typ":"JWT"
	- 해당 알고리즘 지정, 이 알고리즘은 토큰을 검증할 때 signature에서 사용된다 ex.) "alg":"HS256"

*2. payload(내용)* : 토큰에 담을 정보. 정보의 한 조각을 claim이라고 부르며, 키값 쌍으로 구성.
Payload에 필요한 정보들이 담겨있습니다. 각 속성들을 클레임 셋이라고 명칭한다. 
클레임 셋은 JWT에 대한 내용(토큰 생성자(클라이언트)의 정보, 생성 일시 등)이나 클라이언트와 서버 간 주고 받기로 한 값들로 구성된다. 
한 토큰에 여러 개의 claim을 넣을 수 있다. 클레임의 종류엔 3가지가 있다.(Registered, public, private)

	- 등록된(registerd) claim : 서비스에서 필요한 정보가 아닌, 토큰에 대한 정보를 담기 위해 이미 정해진 claim들. 선택적으로 사용함.
		-> iss : 토큰 발급자 (issuer)
		-> sub : 토큰 제목 (subject)
		-> aud : 토큰 대상자 (audience)
		-> exp : 토큰 만료 시간 (expiration). 시간은 NumericDate 형식이어야하며 현재시간 이후어야함.
		-> nbf : Not Before을 의미하며 토큰의 활성 날짜와 비슷한 개념. NumericDate형식이어야하며 이 날짜가지나기 전까지 토큰이 처리되지 않음.
		-> iat : 토큰이 발급된 시간(issued at). 이 값을 이용해 토큰의 age를 판단.
		-> jti : JWT 고유 식별자로서 중복처리 방지에 사용. 일회용 토큰 처리에 유용함.
	- 공개(public) claim : 충돌이 방지된(collision-resistant) 이름을 가지고 있어야 함(충돌 방지를 위해 URI 형식).
		ex.)  "https://velopert.com/jwt_claims/is_admin":true
	- 비공개(private) claim : 서버와 클라이언트 협의 하에 사용되는 claim들. 등록된 claim과 중복될 수 있으니 주의.
		ex.)  "username" : "velopert"
		
			
*3. signature(서명)* : 헤더의 인코딩값과 정보의 인코딩값을 합친 후 비밀키로 해쉬하여 생성.
헤더와 페이로드를 합친 문자열을 서명한 값이다. 
헤더에 정의된 알고리즘과 비밀키를 이용해서 생성하는데, 이 시그니처를 통해 JWT의 위변조를 검사할 수 있다. 
( Payload를 조작한다면 시그니쳐가 달라지기 때문에 유효성을 잃는다.)

###### <JWT의 단점>
	- HTTP Request 과정에서 패킷을 탈취당하는 등으로 토큰이 노출되면 대처가 어렵다.
	- 토큰이 노출되면 토큰의 정보는 별도의 Hashing이 없기 때문에 정보가 그대로 노출될 수 있다.
	- 토큰을 통해 Authentication을 진행하는 경우 서버에서 강제로 세션을 종료하기가 어려워진다.
	(서버가 특정 유저를 로그아웃 시키고 싶을 수 있다. 그 유저가 블랙리스트에 오를수도 있고 유저의 정보가 해킹당해서 일수도 있다.
	서버는 이미 발급된 토큰에 대해서는 대처할 방법이 없기 때문이다.)
	
	




